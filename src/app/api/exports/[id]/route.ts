import { promises as fs } from 'fs'
import JSZip from 'jszip'
import { PDFDocument, StandardFonts } from 'pdf-lib'
import { NextRequest, NextResponse } from 'next/server'

import { prisma } from '@/lib/database'
import { requireAgent } from '@/lib/serverAuth'
import { recordExportTelemetry } from '@/lib/telemetry'

function sanitizeFileName(value: string) {
  return value.replace(/[^a-z0-9\-_\.]/gi, '_')
}

type ArtifactEntry = {
  label: string
  path: string
  size: number
}

type PricingBreakdown = {
  basePrice: number
  addonTotal: number
  priceTotal: number
  lineItems: Array<{ category: string; optionName: string; unitPrice: number; subtotal: number; quantity?: number }>
}

type WhitelistEntry = {
  optionId: string
  overridePrice: number | null
  option: { name: string; price: number; category: string }
}

function computePricingBreakdown(
  whitelists: WhitelistEntry[],
  listing: { basePrice: number } | null,
  selections: Record<string, unknown> | null,
): PricingBreakdown {
  const basePrice = listing?.basePrice ?? 0
  const lineItems: PricingBreakdown['lineItems'] = []
  let addonTotal = 0

  if (selections) {
    const categories: Array<'wall' | 'floor' | 'ceiling'> = ['wall', 'floor', 'ceiling']
    categories.forEach((category) => {
      const value = selections[category]
      if (typeof value !== 'string') return
      const entry = whitelists.find((item) => item.optionId === value)
      if (!entry) return
      const unitPrice = entry.overridePrice ?? entry.option.price
      addonTotal += unitPrice
      lineItems.push({
        category,
        optionName: entry.option.name,
        unitPrice,
        subtotal: unitPrice,
        quantity: 1,
      })
    })
  }

  return {
    basePrice,
    addonTotal,
    priceTotal: Number((basePrice + addonTotal).toFixed(2)),
    lineItems,
  }
}

function parseStoredLineItems(input: unknown): PricingBreakdown['lineItems'] {
  if (!Array.isArray(input)) return []
  const items: PricingBreakdown['lineItems'] = []
  input.forEach((raw) => {
    if (!raw || typeof raw !== 'object') return
    const record = raw as Record<string, unknown>
    const category = typeof record.category === 'string' ? record.category : undefined
    const optionName = typeof record.optionName === 'string' ? record.optionName : undefined
    const unitPrice = typeof record.unitPrice === 'number' && Number.isFinite(record.unitPrice) ? record.unitPrice : 0
    const subtotal = typeof record.subtotal === 'number' && Number.isFinite(record.subtotal) ? record.subtotal : 0
    const quantity = typeof record.quantity === 'number' && Number.isFinite(record.quantity) ? record.quantity : 0
    if (!category || !optionName) return
    items.push({
      category,
      optionName,
      unitPrice,
      subtotal,
      quantity: quantity || undefined,
    })
  })
  return items
}

function mergePricingFromSelection(
  selection: {
    lineItems: unknown
    basePrice: number | null
    addonTotal: number | null
    priceTotal: number
  },
  fallback: PricingBreakdown,
): PricingBreakdown {
  const lineItems = parseStoredLineItems(selection.lineItems)
  if (!lineItems.length) {
    return fallback
  }
  const basePrice = typeof selection.basePrice === 'number' ? selection.basePrice : fallback.basePrice
  const addonTotal = typeof selection.addonTotal === 'number'
    ? selection.addonTotal
    : lineItems.reduce((sum, item) => sum + item.subtotal, 0)
  const priceTotal = typeof selection.priceTotal === 'number'
    ? selection.priceTotal
    : Number((basePrice + addonTotal).toFixed(2))

  return {
    basePrice,
    addonTotal,
    priceTotal,
    lineItems,
  }
}

async function statArtifact(path: string): Promise<number | null> {
  try {
    const stats = await fs.stat(path)
    return stats.size
  } catch (err) {
    console.warn('[export] missing artifact:', path, err)
    return null
  }
}

async function buildChangeLogPdf(
  metadata: Record<string, unknown>,
  selection: { selections: unknown; priceTotal: number },
  pricing: PricingBreakdown,
): Promise<Uint8Array> {
  const pdf = await PDFDocument.create()
  const page = pdf.addPage([595.28, 841.89]) // A4
  const font = await pdf.embedFont(StandardFonts.Helvetica)
  const fontBold = await pdf.embedFont(StandardFonts.HelveticaBold)
  const { height } = page.getSize()
  let cursorY = height - 50

  const writeLine = (text: string, bold = false, size = 12) => {
    const usedFont = bold ? fontBold : font
    page.drawText(text, {
      x: 40,
      y: cursorY,
      size,
      font: usedFont,
    })
    cursorY -= size + 6
  }

  writeLine('Modern Real Estate — Export Change Log', true, 16)
  writeLine(`Generated: ${metadata.generatedAt}`, false, 11)
  writeLine(`Generated by: ${metadata.generatedBy}`, false, 11)
  writeLine(`Unit: ${metadata.unitName || metadata.unitId}`, false, 11)
  cursorY -= 6
  writeLine('Selections', true, 13)
  const selectionEntries =
    selection.selections && typeof selection.selections === 'object'
      ? Object.entries(selection.selections as Record<string, unknown>)
      : []
  selectionEntries.forEach(([category, value]) => {
    const text = `• ${category}: ${String(value)}`
    writeLine(text, false, 11)
  })
  cursorY -= 4
  writeLine(`Base price: ${pricing.basePrice.toFixed(2)}`, true, 12)
  writeLine(`Upgrade total: ${pricing.addonTotal.toFixed(2)}`, true, 12)
  writeLine(`Recorded total price: ${pricing.priceTotal.toFixed(2)}`, true, 12)

  if (pricing.lineItems.length) {
    cursorY -= 4
    writeLine('Line Items', true, 13)
    pricing.lineItems.forEach((item) => {
      writeLine(`• ${item.category.toUpperCase()} — ${item.optionName}: ${item.subtotal.toFixed(2)}`, false, 11)
    })
  }

  writeLine('Artifacts', true, 13)
  const artifacts = (metadata.artifacts as ArtifactEntry[] | undefined) || []
  artifacts.forEach((artifact) => {
    writeLine(`• ${artifact.label} (${artifact.size} bytes)`, false, 11)
  })

  return pdf.save()
}

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  const auth = requireAgent(request)
  if (!auth.ok) return auth.response

  const unit = await prisma.propertyUnit.findUnique({
    where: { id: params.id },
    include: {
      fileUpload: true,
      listing: true,
      whitelists: { include: { option: true } },
    },
  })

  if (!unit) {
    return NextResponse.json({ error: 'Unit not found' }, { status: 404 })
  }

  const artifacts: Array<{ label: string; path: string }> = []

  if (unit.fileUpload?.glbFilePath) {
    artifacts.push({ label: 'model.glb', path: unit.fileUpload.glbFilePath })
  }
  if (unit.fileUpload?.ifcFilePath) {
    artifacts.push({ label: 'model.ifc', path: unit.fileUpload.ifcFilePath })
  }
  if (unit.fileUpload?.processedFilePath) {
    artifacts.push({ label: 'topology.json', path: unit.fileUpload.processedFilePath })
  }
  if (unit.fileUpload?.usdFilePath) {
    artifacts.push({ label: 'model.usd', path: unit.fileUpload.usdFilePath })
  }

  if (artifacts.length === 0) {
    return NextResponse.json({ error: 'No generated assets available for export' }, { status: 400 })
  }

  const artifactEntries: ArtifactEntry[] = []
  for (const artifact of artifacts) {
    const size = await statArtifact(artifact.path)
    if (size != null) {
      artifactEntries.push({ ...artifact, size })
    }
  }
  const latestSelection = await prisma.buyerSelection.findFirst({
    where: { unitId: unit.id },
    orderBy: { updatedAt: 'desc' },
  })

  if (!artifactEntries.length) {
    return NextResponse.json({ error: 'No generated assets available for export' }, { status: 400 })
  }

  let pricing = computePricingBreakdown(
    unit.whitelists as WhitelistEntry[],
    unit.listing,
    latestSelection?.selections as Record<string, unknown> | null,
  )

  if (latestSelection) {
    pricing = mergePricingFromSelection(latestSelection, pricing)
  }

  const metadata = {
    unitId: unit.id,
    unitName: unit.name,
    listing: unit.listing || null,
    generatedAt: new Date().toISOString(),
    generatedBy: auth.user.email,
    artifacts: artifactEntries.map(({ label, size }) => ({ label, size })),
    pricing,
    selections: latestSelection ? {
      data: latestSelection.selections,
      savedAt: latestSelection.updatedAt,
    } : null,
  }

  const zip = new JSZip()
  zip.file('metadata.json', JSON.stringify(metadata, null, 2))

  if (latestSelection) {
    const selectionLines: string[] = []
    selectionLines.push(`Unit ID: ${unit.id}`)
    selectionLines.push(`Generated: ${metadata.generatedAt}`)
    selectionLines.push(`Generated by: ${auth.user.email}`)
    selectionLines.push('')
    selectionLines.push('Buyer Selection Snapshot:')
    Object.entries(latestSelection.selections || {}).forEach(([category, value]) => {
      selectionLines.push(`- ${category}: ${String(value)}`)
    })
    selectionLines.push('')
    selectionLines.push(`Base price: ${pricing.basePrice.toFixed(2)}`)
    selectionLines.push(`Upgrade total: ${pricing.addonTotal.toFixed(2)}`)
    selectionLines.push(`Recorded total price: ${pricing.priceTotal.toFixed(2)}`)
    if (pricing.lineItems.length) {
      selectionLines.push('')
      selectionLines.push('Line items:')
      pricing.lineItems.forEach((item) => {
        const quantity = item.quantity ?? 1
        const subtotal = item.subtotal.toFixed(2)
        selectionLines.push(
          `  - ${item.category.toUpperCase()}: ${item.optionName} — ${quantity} × ${item.unitPrice.toFixed(2)} = ${subtotal}`,
        )
      })
    }
    zip.file('change-log.txt', selectionLines.join('\n'))
    const pdfBytes = await buildChangeLogPdf(metadata, latestSelection, pricing)
    zip.file('change-log.pdf', pdfBytes)
  } else {
    zip.file('change-log.txt', 'No buyer selections recorded for this unit yet.\n')
  }

  for (const artifact of artifactEntries) {
    const buffer = await fs.readFile(artifact.path)
    zip.file(artifact.label, buffer)
  }

  const archive = await zip.generateAsync({
    type: 'uint8array',
    compression: 'DEFLATE',
    compressionOptions: { level: 9 },
  })

  const slug = sanitizeFileName(unit.name || unit.id)
  const filename = `${slug || 'unit'}_${Date.now()}.zip`

  try {
    await prisma.exportLog.create({
      data: {
        unitId: unit.id,
        userId: auth.user.id,
        artifactCount: artifactEntries.length,
        metadata,
      },
    })
  } catch (err) {
    console.warn('[export] failed to record export log', err)
  }

  const archiveCopy = new Uint8Array(archive)
  const archiveBuffer = archiveCopy.buffer.slice(archiveCopy.byteOffset, archiveCopy.byteOffset + archiveCopy.byteLength)

  const response = new NextResponse(archiveBuffer, {
    status: 200,
    headers: {
      'Content-Type': 'application/zip',
      'Content-Disposition': `attachment; filename="${filename}"`,
      'Cache-Control': 'no-store',
    },
  })

  recordExportTelemetry(unit.id, auth.user.email, artifactEntries.length)
  return response
}
